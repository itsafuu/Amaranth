<deck class="mdl-grid { opts.compact ? 'compact' : '' }">


	<div class="mdl-cell mdl-cell--12-col" style="min-height:0;" if={!readonly}>

		<div class="mdl-grid mdl-grid--no-spacing">
			<div class="mdl-cell mdl-cell--8-col mdl-cell--6-col-tablet mdl-cell--4-col-phone">
				<div class="mdl-textfield mdl-js-textfield">
					<label class="mdl-textfield__label">Deck title</label>
					<input class="mdl-textfield__input" name="title" type="text" value="{ deck.title }" onkeyup={ setvalue }  onchange={ update } />
				</div>
			</div>

			<div class="mdl-cell mdl-cell--4-col mdl-cell--2-col-tablet mdl-cell--4-col-phone notsm">
				<div class="mdl-textfield mdl-js-textfield">
					<label class="mdl-textfield__label">Author/s</label>
					<input class="mdl-textfield__input" name="author" type="text" value="{ deck.author }" onkeyup={ setvalue }  onchange={ update } />
				</div>
			</div>
			<div class="mdl-cell mdl-cell--8-col mdl-cell--6-col-tablet mdl-cell--4-col-phone" style="padding-right: 14px;">
				<div class="mdl-textfield mdl-js-textfield" style="margin-bottom: -24px;">
				  <textarea class="mdl-textfield__input" name="description" type="text" rows="1" maxrows="30" id="deckdescription" onfocus={ autosize } onblur={ clearsize } onkeyup={ autosize_and_set }>{ deck.description }</textarea>
				  <label class="mdl-textfield__label" for="deckdescription">Description</label>
				</div>
			</div>


			<div class="mdl-cell mdl-cell--4-col mdl-cell--2-col-tablet mdl-cell--4-col-phone">
				<div class="mdl-selectfield mdl-js-selectfield" style="margin-top: -10px;width: 100%;">
				  <select id="category" name="category" class="mdl-selectfield__select" onchange={ setvalue }>
				    <option value=""></option>
				    <option value="Ally" selected="{ deck.category == 'Ally'}">Ally</option>
				    <option value="Bleed" selected="{ deck.category == 'Bleed'}">Bleed</option>
				    <option value="Combat" selected="{ deck.category == 'Combat'}">Combat</option>
				    <option value="Toolbox" selected="{ deck.category == 'Toolbox'}">Toolbox</option>
				    <option value="Wall" selected="{ deck.category == 'Wall'}">Wall</option>
				    <option value="Vote" selected="{ deck.category == 'Vote'}">Vote</option>
				  </select>
			 	  <label class="mdl-selectfield__label" for="category">Category <span if={ deck_category_calc }>({ deck_category_calc })</span></label>
				</div>
			</div>
		</div>

	</div>



	<div class="mdl-cell mdl-cell--10-col mdl-cell--6-col-tablet" name="readmore" if={ readonly }>
		
		<h2 class="mdl-card__title-text">{ deck.title.split('(')[0] } </h2>
		<p if={ deck.author } class="author">By { deck.author }</p>

		<p style="white-space:pre-wrap; margin-bottom: 0;" if={ deck.description } class="description">{ deck.description || 'Description' } </p>
		
		

		<button class="more-button mdl-button mdl-color-text--primary" onclick={ showmore } if={ showreadmore }>
			<span class="more-button__span">
				<i class="material-icons">&#xE5CF;</i> Read more
			</span>
		</button>


	</div>

	<div class="mdl-cell mdl-cell--2-col mdl-cell--1-col-tablet mdl-cell--4-col-phone" name="readmore" if={ readonly }>
	
		<button class="card-prev mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab" onclick={ prev } if={ prevdeck }>
		  <i class="material-icons">&#xE314;</i>
		</button>

		<button class="card-next mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab" onclick={ next } if={ nextdeck }>
		  <i class="material-icons">&#xE315;</i>
		</button>

	</div>


	<div class="deck-crypt mdl-cell mdl-cell--5-col  mdl-cell--7-col-tablet mdl-cell--4-col-phone mdl-color--white mdl-shadow--2dp">
		<div class="deck-header">

			<button class="deck-button mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab" onclick={ showcrypt } if={ !readonly }>
			  <i class="material-icons">&#xE145;</i>
			</button>

			<button class="mdl-button mdl-js-button  mdl-color-text--grey-400" style="float:right; margin-top:3px; margin-right: 8px;" if={ !readonly } id="sortcrypt_btn">
				<i class="material-icons" >&#xE8d5;</i>
			</button>

			<h4>Crypt <span if={ crypt.total }>({ crypt.total })</span></h4>

			<ul class="mdl-menu mdl-js-menu" for="sortcrypt_btn">
				<li class="mdl-menu__item" onclick={ sortcryptby } data-sort="name">Name</li>
				<li class="mdl-menu__item" onclick={ sortcryptby } data-sort="capacity">Capacity</li>
				<li class="mdl-menu__item" onclick={ sortcryptby } data-sort="clan">Clan</li>
				<li class="mdl-menu__item" onclick={ sortcryptby } data-sort="group">Group</li>
				<li class="mdl-menu__item" onclick={ sortcryptby } data-sort="quantity">Quantity</li>
			</ul>

		</div>

		
		<!-- Crypt cards -->
		<div class="picker-list mdl-list">
			<div class="mdl-list__item" each={ crypt } data-id="{ id }">

				<span class="mdl-list__item-primary-content" onclick={ showcryptcard }>
					<div>{ name } <span class="clan-name"> { clan }:{ group }</span><br/>
						<small class="crypt-details">
							<span class="capacity">{ capacity }</span> <rawupdate html={ icons }></rawupdate>   
						</small>
					</div>
				</span>

				<button if={ deck && !readonly } class="mdl-button mdl-js-button mdl-button--icon mdl-list__item-secondary-action" onclick={ removecard } >
					<i class="material-icons">&#xE15C;</i>
				</button>

				<span if={ deck } class="picker-total total_in_deck mdl-list__item-secondary-action">{ parent.deck.cards[ id ] || 0 }</span>


				<button if={ deck && !readonly } class="mdl-button mdl-js-button mdl-button--icon mdl-list__item-secondary-action" onclick={ addcard }>
					<i class="material-icons">&#xE147;</i>
				</button> 

			</div>
		</div>


		<div class="illegal" if={ illegal_crypt }>{ illegal_crypt }</div>		

		<!-- recommended cards -->
		<div class="picker-list mdl-list" style="background:#F5F5F5" if={ !readonly }  show={ crypt.length || library.total }>


			<div class="picker-type" onclick={ togglerecommendedcrypt } class={ !showrecommendedcrypt ? 'padbot' : ''} if={ app.twda }><span if={ !showrecommendedcrypt }> Show </span>Recommended Crypt Cards</div>	


			<div class="mdl-list__item" show={ showrecommendedcrypt } >
				<span class="mdl-list__item-primary-content">
					<label class="mdl-switch mdl-js-switch" for="match_crypt_only">
						  <input type="checkbox" id="match_crypt_only" name="match_crypt_only" 
						  	class="mdl-switch__input mdl-list__item-secondary-action" checked={ match_crypt_only } onchange={ toggle_user_setting }>
						  <span class="mdl-switch__label">Match only crypt cards</span>
					</label>
				</span>
			</div>			

			<div class="mdl-list__item" show={ showrecommendedcrypt } >
				<span class="mdl-list__item-primary-content">
					<label class="mdl-switch mdl-js-switch" for="match_crypt_constrain">
						  <input type="checkbox" id="match_crypt_constrain" name="match_crypt_constrain" 
						  	class="mdl-switch__input  " checked={ match_crypt_constrain } onchange={ toggle_user_setting }> 
						  <span class="mdl-switch__label">Constrained matching</span>
					</label>
				</span>
			</div>			

			<div class="mdl-list__item crypt-recommendation" 
				each={ recommended_crypt } 
				data-total={recommended_crypt.length} 
				data-id="{ id }" 
				no-reorder
				if={ showrecommendedcrypt }>
				

				<span class="mdl-list__item-primary-content" onclick={ showcryptcard } data-id={ id }>
					<div>{ name } <span class="clan-name"> { clan }:{ group }</span><br/>
						<small class="crypt-details">
							<span class="capacity">{ capacity }</span> <rawupdate html={ icons } if={ showrecommendedcrypt } ></rawupdate>
						</small>
					</div>
				</span>

				<span class="picker-total total_in_deck mdl-list__item-secondary-action">{ recommended_qty }</span>

				<button if={ deck && !readonly } class="mdl-button mdl-js-button mdl-button--icon mdl-list__item-secondary-action" 
					data-qty={ recommended_qty || 1} 
					onclick={ addcard } 
					ontouchstart={ addcard }>
					<i class="material-icons" data-qty={ recommended_qty || 1 } >&#xE147;</i>
				</button> 

			</div>

			<br/ if={ !showrecommendedcrypt }>

		</div>

		<!-- Happy Families -->
		<div class="picker-list mdl-list" if={ !readonly }>
	
			<div class="picker-type" onclick={ togglehappy } class={ !showhappy ? 'padbot' : ''} if={ app.twda }><span if={ !showhappy }> Show </span>Happy Families</div>	

			<table class="happyfamilies mdl-data-table" width="100%" if={ showhappy }>
			  <thead>
			    <tr>
			      <th class="mdl-data-table__cell--non-numeric"><span contenteditable="true" onkeydown={ sethappy } onblur={ blurhappy }>{ happycount }</span> cards, <span contenteditable="true" onkeydown={ sethappymax } onblur={ blurhappy }>{ happymax }</span> disciplines</th>
			      
					<th>Rec<span class="notsm">ommended</span></th>
					<th>Deck</th>

			    </tr>
			  </thead>
			  <tbody>
			    <tr  each={ item in happyfamilies }>
			      <td class="mdl-data-table__cell--non-numeric">
						<icon class="{ item.name }" if={ item.name != 'No discipline' && item.name != 'Masters' }></icon> 
						<span if={ item.name == 'Masters' }>Masters <span contenteditable="true" onkeydown={ sethappyratio } onblur={ blurhappy }>{ happyratio }</span>%</span>
						<span if={ item.name == 'No discipline' }>No discipline <span contenteditable="true" onkeydown={ sethappydisc } onblur={ blurhappy }>{ happydis }</span>%</span>	
						<span if={ item.name != 'Masters' && item.name != 'No discipline' }>{ item.name }</span> 
			      </td>
			      <td>{item.total}</td>
			      <td>{item.indeck}</td>
			    </tr>
			  </tbody>
			</table>
		</div>

	</div>


	<div class="deck-library mdl-cell mdl-cell--5-col  mdl-cell--7-col-tablet mdl-cell--4-col-phone mdl-color--white mdl-shadow--2dp">
		<div class="deck-header">

			<button class="deck-button mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab" onclick={ showlib } if={ !readonly }>
			  <i class="material-icons">&#xE145;</i>
			</button>

			<h4>Library <span if={ library.total }>({ library.total })</span> <span class="poolcost" title="Total pool cost" if={ library.pool }>{ library.pool }</span> <span class="bloodcost" title="Total blood cost" if={ library.blood }>{ library.blood }</span></h4>

		</div>

		
		<div class="picker-list mdl-list" each={ type in cardtypes }>
			<div class="picker-type" if={ name != 'total' }>{ library[type].total } { type }</div>

			<div class="mdl-list__item"	no-reorder each={ library[type] }>
				<span class="mdl-list__item-primary-content" onclick={ showlibcard }>
					<span>{ name } <span class="banned" if={ banned }>Banned</span></span>
				</span>

				<button if={ deck && !readonly } class="mdl-button mdl-js-button mdl-button--icon mdl-list__item-secondary-action" onclick={ removecard }>
					<i class="material-icons">&#xE15C;</i>
				</button>

				<span if={ deck } class="picker-total total_in_deck mdl-list__item-secondary-action">{ parent.deck.cards[ id ] || 0 }</span>

				<button if={ deck && !readonly } class="mdl-button mdl-js-button mdl-button--icon mdl-list__item-secondary-action" 
					onclick={ addcard }>
					<i class="material-icons">&#xE147;</i>
				</button> 

			</div>
		</div>

		<div class="illegal" if={ illegal_library }>{ illegal_library }</div>		

		<!-- recommended library cards -->
		<div class="picker-list mdl-list" style="background:#F5F5F5"  if={ !readonly } show={ crypt.length || library.total }>


			<div class="picker-type" onclick={ togglerecommendedlib } class={ !showrecommendedlib? 'padbot' : ''}><span if={ !showrecommendedlib }> Show </span>Recommended Cards</div>	

			<div class="mdl-list__item" show={ showrecommendedlib }>
				<span class="mdl-list__item-primary-content">
					<label class="mdl-switch mdl-js-switch" for="match_lib_only">
						  <input type="checkbox" id="match_lib_only" name="match_lib_only" class="mdl-switch__input" checked={ match_lib_only } onchange={ toggle_user_setting }>
						  <span class="mdl-switch__label">Match only library cards</span>
					</label>
				</span>
			</div>				

			<div class="mdl-list__item" show={ showrecommendedlib }>
				<span class="mdl-list__item-primary-content">
					<label class="mdl-switch mdl-js-switch" for="match_lib_constrain">
						  <input type="checkbox" id="match_lib_constrain" name="match_lib_constrain" class="mdl-switch__input" checked={ match_lib_constrain } onchange={ toggle_user_setting }>
						  <span class="mdl-switch__label">Constrained matching</span>
					</label>
				</span>
			</div>				

			<div class="mdl-list__item library-recommendation" 
				each={ recommended_library } 
				data-total={recommended_library.length} 
				data-id="{ id }" 
				no-reorder
				if={ showrecommendedlib }>
				
				<span class="mdl-list__item-primary-content" onclick={ showlibcard }  data-id={ id }>
					<span>{ name } <span class="banned" if={ banned }>Banned</span></span>
				</span>

				<span class="picker-total total_in_deck mdl-list__item-secondary-action">{ recommended_qty }</span>

				<button if={ deck && !readonly } class="mdl-button mdl-js-button mdl-button--icon mdl-list__item-secondary-action" 
					data-qty={ recommended_qty || 1 } 
					onclick={ addcard } 
					ontouchstart={ addcard }>
					<i class="material-icons" data-qty={ recommended_qty || 1 } >&#xE147;</i>
				</button> 

			</div>
			<br/ if={ !showrecommendedlib }>
		</div>

	</div>

	<div class="deck-buttons mdl-cell mdl-cell--2-col mdl-cell--1-col-tablet mdl-cell--4-col-phone">

		<button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored { !deck.dirty ? 'mdl-button--disabled' : '' }" onclick={ save } if={ !readonly }>
			<i class="material-icons">&#xE2C3;</i> Save
		</button>		
		
		<button class="mdl-button mdl-js-button mdl-button--raised mdl-button--accent"  onclick={ printdeck } if={ deck.cards != {} }>
			<i class="material-icons">&#xE8AD;</i> Print
		</button>

		<button class="mdl-button mdl-js-button mdl-button--raised"  onclick={ share } if={ deck.id }>
			<i class="material-icons">&#xE80D;</i> Share
		</button>	

		<button class="mdl-button mdl-js-button mdl-button--raised" onclick={ drawcards } if={ !opts.twda }>
			<i class="material-icons">&#xE5D5;</i> Draw
		</button>

		<button class="mdl-button mdl-js-button mdl-button--raised" onclick={ seating } if={ !opts.twda }>
			<i class="material-icons">people</i> Seating
		</button>


		
		<button class="mdl-button mdl-js-button mdl-button--raised { deck.dirty ? 'mdl-color--red-800 mdl-color-text--red-50' : '' }" onclick={ cancel } style="margin-bottom: 10px;"  if={ !readonly }>
			<i class="material-icons" if={ deck.dirty }>&#xE5CD;</i>  { !deck.dirty ? 'Back' : 'Cancel' } 
		</button>

		<button class="mdl-button mdl-js-button mdl-button--raised" onclick={ back } style="margin-bottom: 10px;"  if={ readonly }>
			Back
		</button>

		<br/>
		<br/>

		<button class="mdl-button mdl-js-button mdl-button--raised"  onclick={ quickstart } if={ deck.id && !readonly && ! deck.isquickstart && ! deck.isquickstart_submitted }>
			<i class="material-icons">&#xE01F;</i> Quickstart
		</button>

		<button class="mdl-button mdl-js-button mdl-button--raised" id="exportbtn">
			<i class="material-icons">&#xE2C4;</i> Export
		</button>
		
		<button class="mdl-button mdl-js-button mdl-button--raised"  onclick={ deckversions } if={ !readonly || deck.versions && deck.versions.length > 1 }>
			<i class="material-icons">assignment</i> Versions
		</button>

		<button class="mdl-button mdl-js-button mdl-button--raised" onclick={ duplicate } if={ deck.id && deck.cards != {} }>
			<i class="material-icons">&#xE14D;</i> Copy
		</button>

		<ul class="mdl-menu mdl-js-menu" for="exportbtn">
			<li class="mdl-menu__item" onclick={ export_text }>Text</li>
			<li class="mdl-menu__item" onclick={ export_lackey }>Lackey</li>
			<li class="mdl-menu__item" onclick={ export_jol }>JOL</li>
		</ul>

		<button class="mdl-button mdl-js-button mdl-button--raised"  onclick={ addcomment } if={ deck.id && readonly && !opts.twda }>
				<i class="material-icons">comment</i> Comment
		</button>

		<button class="mdl-button mdl-js-button mdl-button--raised"  onclick={ printsome } if={ !opts.twda } >
			<i class="material-icons">&#xE8AD;</i> Print some
		</button>		

		<button class="mdl-button mdl-js-button mdl-button--raised" onclick={ makepublic } if={ !readonly && !deck.ispublic && app.allowpublic && !deck.notowner }>
			<i class="material-icons">&#xE80B;</i> Public
		</button>

		<button class="mdl-button mdl-js-button mdl-button--raised" onclick={ makeprivate } if={ !readonly && deck.ispublic && app.allowpublic && !deck.notowner }>
			<i class="material-icons">&#xE32A;</i> Private
		</button>

		<button class="mdl-button mdl-js-button mdl-button--raised" onclick={ deletedeck } if={ !readonly }>
			<i class="material-icons">&#xE872;</i> Delete
		</button>






	</div>

	<div class="deck__order-set mdl-cell mdl-cell--10-col  mdl-cell--7-col-tablet mdl-cell--4-col-phone _mdl-color--white _mdl-shadow--2dp" each={ set in sets} if={ order_links[set] }>
		<h2 class="deck__order-title mdl-card__title-text"><span class="notsm">Contains</span>&nbsp;{ set }</h2>

		<button class="deck__order-btn mdl-button mdl-js-button mdl-button--raised"  onclick={ buycards } >
			<i class="material-icons">shopping_cart</i>Order Now
		</button>
		

	
		
		
	</div>

	<style type="text/css">
		.deck__order-set{
		    padding: 10px;
		    border-bottom: 1px dashed #CCC;
		    margin-bottom: 0;
		    padding-bottom: 20px;
    		display: flex;
    		flex-flow: row;
		}

		.deck__order-set:last-child{
			border-bottom: none;
		}

		.deck__order-title{
		    color: #777;
		    font-size: 140%;
		    vertical-align: middle;
		    line-height: 180%;	
		        width: 100%;
		}



	</style>



	<script>

		this.mixin(amaranth_util.prototype)	
		this.mixin(twda.prototype)	

		this.deck       = opts.deck 
		this.decks      = opts.decks || [] 
		this.backup     = JSON.parse(JSON.stringify(this.deck))
		this.cardorder  = app.cardorder 
		this.cryptorder = app.get_user_setting('cryptorder') || app.default_cryptorder 
		this.readonly   = opts.deck.readonly || 0
		this.happycount = app.get_user_setting('happycount') || 75 	// target number of library cards
		this.happyratio = app.get_user_setting('happyratio') || 20 	// master card ratio
		this.happydis   = app.get_user_setting('happydis')   || 50 	// percentage of no displine cards
		this.happymax   = app.get_user_setting('happymax')   || 4 	// max number of displines 
		this.showhappy  = app.get_user_setting('showhappy')  || 0 	// show happy families or not

		this.showrecommendedcrypt = app.get_user_setting('showrecommendedcrypt')   || 0
		this.showrecommendedlib   = app.get_user_setting('showrecommendedlib')     || 0

		this.match_crypt_only      = app.get_user_setting('match_crypt_only')     
		this.match_crypt_constrain = app.get_user_setting('match_crypt_constrain')
		this.match_lib_only        = app.get_user_setting('match_lib_only')       
		this.match_lib_constrain   = app.get_user_setting('match_lib_constrain')  


		this.illegal_crypt   = false 
		this.illegal_library = false 

		this.order_links = {
			'Lost Kindred':         'https://amaranth.vtes.co.nz/api/buy?expansion=Lost+Kindred',
			'Keepers of Tradition': 'https://amaranth.vtes.co.nz/api/buy?expansion=Keepers+of+Tradition'
		}

		this.sets = []
		
		this.order_buttons = []

		var setNextPrev = function(){
			var decks = this.decks 
			var deck = this.deck 
			var count = decks.length

			for(var i = 0; i < count; i++) {
				if(decks[i] == deck){
					this.prevdeck = decks[i-1]
					this.nextdeck = decks[i+1]
					this.update()
					return 
				}
			}
		}.bind(this)

		setNextPrev()

		next(e) {
			e.preventUpdate = true
			var deck = this.nextdeck
			if(!deck) return
			this.show_tournment_deck(deck, this.decks)
		}				

		prev(e) {
			e.preventUpdate = true
			var deck = this.prevdeck
			if(!deck) return
			this.show_tournment_deck(deck, this.decks)
		}

		setvalue(e) {
			e.preventUpdate = true
			this.deck[e.target.name] = $(e.target).val().trim()

			this.deck.dirty = 1  

			if(e.keyCode == 13 && e.target.name != 'description'){
				return e.target.blur()
				app.save()
			}
		}


		showmore(e) {
			$(this.readmore).addClass('readmore--expanded')
		}

		buycards(e){
			e.preventUpdate = true
			e.preventDefault()
			var url = this.order_links[e.item.set]
			window.open(url, '_system')
		
		}

		sethappyvalue(e, name, value) {
			e.preventUpdate = true 			

			if(e.keyCode == 13) {
				e.preventDefault()
				e.target.blur()
				this.update()
				return false
			}

			setTimeout(function(){
				this[name] = value()
				$(e.target).data('validvalue', this[name])
				this.updatehappy()
			}.bind(this),10)

			return true 
		}

		sethappymax(e){
			return this.sethappyvalue(e, 'happymax', function(){
				return Math.min(Math.max(parseInt(e.target.innerText) || 0, 0),10) 
			})
		}

		sethappydisc(e){
			return this.sethappyvalue(e, 'happydis', function(){
				return Math.min(Math.max(parseInt(e.target.innerText) || 0, 0),100) 
			})
		}

		sethappyratio(e){
			return this.sethappyvalue(e, 'happyratio', function(){
				return Math.min(Math.max(parseInt(e.target.innerText) || 0, 0),100) 
			})
		}

		sethappy(e){
			return this.sethappyvalue(e, 'happycount', function(){
				return Math.min(Math.max(parseInt(e.target.innerText) || 70, 60),90)
			})
		}

		updatehappy() {
			clearInterval(this.happyint)
			this.happyint = setTimeout(function(){				
				app.set_user_setting('happycount', this.happycount) 
				app.set_user_setting('happyratio', this.happyratio)
				app.set_user_setting('happymax',   this.happymax)
				app.set_user_setting('happydis',   this.happydis)
				this.update()
			}.bind(this), 2000)
		}

		blurhappy(e) {
			if( $(e.target).data('validvalue')) e.target.innerHTML = $(e.target).data('validvalue')
		}

		togglehappy(e) {
			this.showhappy = !this.showhappy
			app.showhappy = this.showhappy
		}

		togglerecommendedcrypt(e) {
			this.showrecommendedcrypt = !this.showrecommendedcrypt
			app.showrecommendedcrypt = this.showrecommendedcrypt
			app.set_user_setting('showrecommendedcrypt', this.showrecommendedcrypt)
		}

		togglerecommendedlib(e) {
			this.showrecommendedlib = !this.showrecommendedlib
			app.showrecommendedlib = this.showrecommendedlib
			app.set_user_setting('showrecommendedlib', this.showrecommendedlib)
		}


		sortcryptby(e){
			e.preventUpdate = true 
			e.preventDefault()
			var order = $(e.target).data('sort')
			this.cryptorder = order
			app.set_user_setting('cryptorder', this.cryptorder) 
			this.update()
		}

		drawcards(e){
			e.preventUpdate = true 
			e.preventDefault()

			var dom = document.createElement('draw-cards')
			riot.mount(dom, 'draw-cards', {deck: this.deck })
		
			app.setmodal(dom, function(modal){
				$(modal).draggable({handle: '.mdl-cell:first'})
				$(modal).addClass('draw-cards')
				$(modal).css('overflow-y', 'auto')
			})
		}


		seating(e){
			e.preventUpdate = true 
			e.preventDefault()

			var dom = document.createElement('meta-game')
			riot.mount(dom, 'meta-game', {deck: this.deck })
		
			app.setmodal(dom, function(modal){
				$(modal).draggable({handle: '.mdl-cell:first'})
				$(modal).addClass('meta-game')
				$(modal).css('overflow-y', 'auto')
			})
		}


		deckversions(e){
			e.preventUpdate = true 
			e.preventDefault()

			var dom = document.createElement('deck-versions')
			riot.mount(dom, 'deck-versions', {deck: this.deck })
		
			app.setmodal(dom, function(modal){
			//	$(modal).draggable({handle: '.mdl-cell:first'})
				$(modal).addClass('deck-versions')
				$(modal).css('overflow-y', 'auto')
			})
		}

		addcomment(e) {
			e.preventUpdate = true
			var dom = document.createElement('addcomment')
			setTimeout(function(){
				app.setmodal(dom, function(modal){
					modal.css('overflow-y', 'auto').css('max-width', '500px').css('margin-left', '-250px')
				})
				
				riot.mount(dom, 'addcomment', { deck: this.deck })

			}.bind(this), 1)
		}


		showcrypt(e){
			e.preventUpdate = true 
			e.preventDefault()

			if(app.crypt) {
				var dom = app.crypt
			} else {
				var dom = document.createElement('crypt-cards')
				app.crypt = dom 
				riot.mount(dom, 'crypt-cards', {deck: this.deck })
			}



			app.setmodal(dom, function(modal){

				// Ensure crypt is part of path (back button support)
				if(window.location.hash.indexOf('/crypt') == -1) {
					riot.route(window.location.hash.split('#')[1] + '/crypt')				
				}

				$(modal).draggable({handle: '.mdl-cell:first'})
				$(modal).addClass('find-cards')
			})
		}

		showlib(e){
			e.preventUpdate = true 
			e.preventDefault()

			var dom = document.createElement('library-cards')
			app.setmodal(dom, function(modal){

				// Ensure library is part of path (back button support)
				if(window.location.hash.indexOf('/crypt') == -1) {
					riot.route(window.location.hash.split('#')[1] + '/library')				
				}

				$(modal).draggable({handle: '.mdl-cell:first'})
				$(modal).addClass('find-cards')

			})
			riot.mount(dom, 'library-cards', {deck: this.deck })
		}


		printsome(e){
			e.preventUpdate = true 
			e.preventDefault()

			var dom = document.createElement('print')
			app.setmodal(dom, function(modal){
				$(modal).css({
					'width':  '96%',
					'left':   '2%',
					'margin': 'auto',
					'overflow-y': 'auto',
					'-webkit-overflow-scrolling': 'touch'
				})
			})
			riot.mount(dom, 'print', {deck: this.deck })
		}		

		showcryptcard(e) {
			e.preventUpdate = true
			this.update()
			var card = e.item 
			var dom = document.createElement('card')
			setTimeout(function(){
				app.setmodal(dom, function(modal){
					modal.css('overflow-y', 'auto').css('background', 'black').addClass('card').addClass('large')
				})
				riot.mount(dom, 'card', {card: card, cards: this.crypt, deck: this.deck })
				componentHandler.upgradeDom();						
			}.bind(this),1)
		}

		showlibcard(e) {
			e.preventUpdate = true
			this.update()
			var card = e.item 
			var dom = document.createElement('card')
			setTimeout(function(){
				app.setmodal(dom, function(modal){
					modal.css('overflow-y', 'auto').css('background', 'black').addClass('card').addClass('large')
				})
				riot.mount(dom, 'card', {card: card, cards: this.librarycards, deck: this.deck })
				componentHandler.upgradeDom();			
			}.bind(this),1)
		}

		addcard(e) {
			var card = e.item 

			var add = parseInt(e.target.getAttribute('data-qty')) || 1
			var qty = (this.deck.cards[card.id] || 0) + add
			this.deck.cards[card.id] = qty
			this.deck.dirty = 1
			app.save()

		}

		removecard(e) {
			var card = e.item 
			var qty = this.deck.cards[card.id]

			if(qty === 0) {
				delete this.deck.cards[card.id]
			}

			else {
				qty = Math.max((qty - 1 || 0),0)
				this.deck.cards[card.id] = qty
			}

			this.deck.dirty = 1

			app.save()
		}

		export_text(e) {
			e.preventUpdate = true
			this.exportdeck('text')
		}

		export_lackey(e) {
			e.preventUpdate = true
			this.exportdeck('lackey')
		}


	export_jol(e) {
		e.preventUpdate = true
		this.exportdeck('jol')
	}

	exportdeck(format) {
		// Client-side export - no login required
		var exportText = this.generateExportText(format);
		
		if (exportText) {
			swal({type:'success', text: 'Downloading File.', showConfirmButton: false, allowOutsideClick: true, timer: 2 * 1000}).done()
			
			// Create download
			var blob = new Blob([exportText], {type: 'text/plain'});
			var url = window.URL.createObjectURL(blob);
			var a = document.createElement('a');
			a.href = url;
			var extension = format === 'text' ? 'txt' : format;
			var filename = (this.deck.title || 'deck').split(' ').join('_').replace(/[^\w]/g, '') + '.' + extension;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			window.URL.revokeObjectURL(url);
		} else {
			swal({type:'error', text: 'Export format not supported yet.', showConfirmButton: false, allowOutsideClick: true, timer: 3 * 1000}).done()
		}
	}

	generateExportText(format) {
		var text = '';
		var deck = this.deck;
		
		// Parse the deck to populate crypt and library arrays
		this.deck_parser(deck.cards);
		var crypt = this.crypt || [];
		var library = this.librarycards || [];
		
		if (format === 'text') {
			// Plain text format
			text = deck.title + '\n';
			if (deck.author) text += 'Author: ' + deck.author + '\n';
			if (deck.description) text += '\n' + deck.description + '\n';
			
			text += '\n-- Crypt (' + crypt.length + ') --\n';
			crypt.forEach(function(card) {
				text += (card.qty || 1) + 'x ' + card.name + '\n';
			});
			
			text += '\n-- Library (' + library.length + ') --\n';
			library.forEach(function(card) {
				text += (card.qty || 1) + 'x ' + card.name + '\n';
			});
			
		} else if (format === 'lackey') {
			// Lackey format
			crypt.forEach(function(card) {
				for (var i = 0; i < (card.qty || 1); i++) {
					text += card.name + '\n';
				}
			});
			library.forEach(function(card) {
				for (var i = 0; i < (card.qty || 1); i++) {
					text += card.name + '\n';
				}
			});
			
		} else if (format === 'jol') {
			// JOL format (similar to text but different formatting)
			crypt.forEach(function(card) {
				text += (card.qty || 1) + ' ' + card.name + '\n';
			});
			library.forEach(function(card) {
				text += (card.qty || 1) + ' ' + card.name + '\n';
			});
		}
		
		return text;
	}

	duplicate(e) {
		e.preventUpdate = true
		var deck = app.copydeck(this.deck)
		riot.route('/deck/' + deck.uuid)
	}
	save(e){
		e.preventUpdate = true

		if(!this.deck.title) {
			swal({
				type:'warning', text: 'Please enter a title.', showConfirmButton: false, allowOutsideClick: true, timer: 1.5 * 1000
			}).done()	

			this.title.focus()

			return false 
		}

		// Save to localStorage
		app.save()
		
		// Mark as saved
		this.deck.dirty = 0
		
		// Show confirmation
		swal({
			type:'success', 
			text: 'Deck saved.', 
			showConfirmButton: false, 
			allowOutsideClick: true, 
			timer: 1000
		}).done()
	}
	
		printdeck(e) {
			e.preventUpdate = true	

			var ifloggedin = function(){
				// Show please wait dialogue
				swal({type:'info', text: 'Generating PDF...', showConfirmButton: false, allowOutsideClick: false, timer: 25 * 1000 }).done()	

				app.callapi('/api/print', {
					deck: JSON.stringify(this.deck),
					format: (parseInt(app.get_user_setting('use_old_cards'))  ? 'old' : 'new') 
				}, function(response){


					if(response.success) {
						swal({type:'success', text: 'Downloading PDF.', showConfirmButton: false, allowOutsideClick: true, timer: 5 * 1000}).done()	
						var download =  response.result 
						app.downloadpdf(download, this.deck.title)
					}

					else {
						var error = 'There\'s been an error — please try again.'

						if(response.error && response.error.code == -1) {
							var error = response.error.message
						}

						swal({type:'error', text: error, showConfirmButton: false, allowOutsideClick: true, timer: 5 * 1000}).done()	
					}
				}.bind(this))
			}.bind(this)


			if(app.user.id) {
				ifloggedin()
			} 

			else {
				app.login(ifloggedin)
			}
		}

		share(e) {
			e.preventUpdate = true
			app.append('share', {
				title:   'Share this deck',
				help:    'People with this link can view and copy the deck:',
				subject: 'Check out this VTES Deck',
				url:     'https://amaranth.vtes.co.nz/#deck/' + this.deck.uuid

			})
		}

		cancel(e){
			e.preventUpdate = true		
			var backup = this.backup

			var onconfirm = function(){
				delete backup['dirty']

				// Just delete it
				if(Object.keys(backup.cards).length == 0){
					app.decks.splice(app.decks.indexOf(this.deck),1)
				}

				// Restore old version
				else {
					for(var i = 0; i < app.decks.length; i++ ) {
						if(app.decks[i].uuid == backup.uuid) {
							app.decks.splice(i, 1, backup)
							app.save()
						}
					}
				}

				riot.route('/decks')
			}

			if(this.deck.dirty) {
				// Show please wait dialogue
				swal({
					type:'warning', 
					title: '',
					text: 'Discard changes?', 
					showConfirmButton: true,
					showCancelButton: true,  
					allowOutsideClick: true,
					confirmButtonText: 'Yes',
					cancelButtonText: 'No'
				}).then(function(confirmed){			
					if(confirmed) {
						onconfirm()
					}
				}.bind(this), function(dismiss){}).done()	
			}

			else {
				onconfirm()
			}

		}

		back(e) {
			//riot.route('/quickstart')
			history.go(-1)
		}

		deckaction(text, url, onsuccces, title) {

			// Show please wait dialogue
			swal({
				type:'warning', 
				title: title || '',
				text: text || 'Are you sure?', 
				showConfirmButton: true,
				showCancelButton: true,  
				allowOutsideClick: true,
				confirmButtonText: 'Yes',
				cancelButtonText: 'No'
			}).then(function(confirmed){			
				if(this.deck.id && confirmed) {
					app.callapi(url, {deck: JSON.stringify(this.deck) }, function(response){
						if(response.success) {
							onsuccces()							
						} 
						else {
							var error = 'There\'s been an error — please try again.'
							if(response.error && response.error.code == -1) {
								error = response.error.message
							}

							swal({type:'error', text: error, showConfirmButton: false, allowOutsideClick: true, timer: 5 * 1000}).done()	
						}

					})
				} else if(confirmed) {
					onsuccces()
				}
			}.bind(this), function(dismiss){
				//
			}).done()	
		}

		deletedeck(e) {
			e.preventUpdate = true	

			var onsuccces = function(){
				app.decks.splice(app.decks.indexOf(this.deck),1)
				app.save()				
				riot.route('/decks')	

				swal({
					type:'success', 
					text: 'Deck deleted.', 
					showConfirmButton: false, 
					allowOutsideClick: true, 
					timer: 3000
				})

				setTimeout(function(){swal.close()}, 3001)

			}.bind(this)

			this.deckaction('Are you sure you want to delete this deck?', '/api/deck/delete', onsuccces)
		}
	
		quickstart(e) {
			e.preventUpdate = true	

			var onsuccces = function(){
				this.deck.isquickstart_submitted = 1
				app.save()
				swal({
					type:'success', 
					text: 'Deck submitted.', 
					showConfirmButton: false, 
					allowOutsideClick: true, 
					timer: 3000
				})
				this.update()
				setTimeout(function(){swal.close()}, 3001)
			}.bind(this)

			this.deckaction('Are you sure you want to submit this deck?', '/api/deck/quickstart', onsuccces, 'Submit Quickstart')

		}

		makepublic(e) {
			e.preventUpdate = true	

			var onsuccces = function(){
				this.deck.ispublic = 1
				app.save()
				swal({
					type:'success', 
					text: 'Deck marked public.', 
					showConfirmButton: false, 
					allowOutsideClick: true, 
					timer: 3000
				})
				setTimeout(function(){swal.close()}, 3001)
				this.update()
			}.bind(this)

			this.deckaction('Are you sure? — anyone with the link will be able to edit it.', '/api/deck/public', onsuccces, 'Make Deck Public')

		}

		makeprivate(e) {
			e.preventUpdate = true	

			var onsuccces = function(){
				this.deck.ispublic = 0
				app.save()				
				swal({
					type:'success', 
					text: 'Deck marked private.', 
					showConfirmButton: false, 
					allowOutsideClick: true, 
					timer: 3000
				})
				this.update()
				setTimeout(function(){swal.close()}, 3001)
			}.bind(this)

			this.deckaction('Are you sure? — only the owner will be able to edit it.', '/api/deck/private', onsuccces, 'Make Deck Private')

		}
	

		var onedit = function(){
			this.update()			
		}.bind(this)


		this.on('mount', function(){

			console.log('opts', JSON.stringify(opts))

			if(opts.deck.title) {
				document.title = 'VTES Deck: ' + opts.deck.title
			}

			setTimeout(function(){

				if(this.readonly) {

					var h = this.readmore.scrollHeight
					if(h > 120) {
						this.showreadmore = 1
						this.update()
					}

					// Highlight links (restricted)
					var el = $(this.root).find('.description'); 
					el.html(app.highlight(el.text()))	
				}

			}.bind(this), 10)

			app.on('deckchange', onedit)
		})

		this.on('unmount', function(){
			app.off('deckchange', onedit)

			if(app.crypt) {
				app.crypt = null 
			}

			document.title = app.title 

		})


		this.on('update', function(){

			// Populate deck data
			this.deck_parser(this.deck.cards)

			// Sort crypt	
			if(this.cryptorder) {
				app.sortcrypt(this.crypt, this.cryptorder, this.deck)
			} 

			// app.sortlibrary(this.libray, 'name', this.deck)


			if(!this.readonly && (this.showrecommendedcrypt || this.showrecommendedlib)) {		
				this.recommended_crypt   = this.recommend_crypt({
						cards: Object.keys(this.deck.cards), 
						match_crypt_only: this.match_crypt_only, 
						match_crypt_constrain: this.match_crypt_constrain
					}).slice(0, 9)

				this.recommended_library = this.recommend_library({
						cards: Object.keys(this.deck.cards),
						match_lib_only: this.match_lib_only, 
						match_lib_constrain: this.match_lib_constrain	
					}).slice(0, 9)

				// Deal with rendering bug
				setTimeout(function(){
					$(this.root).find('.crypt-recommendation[data-total!="' + this.recommended_crypt.length + '"]').remove()
					$(this.root).find('.library-recommendation[data-total!="' + this.recommended_library.length + '"]').remove()
				}.bind(this), 10)
			}

			if(!this.deck.category) {
				this.deck_category_calc = this.deck_category( this.deck.cards )
			}

			if(this.showhappy) {
				this.happyfamilies = app.happyfamilies(this.crypt, this.librarycards, this.happycount, this.happyratio, this.happymax, this.happydis) 
			}

	
		})
	</script>

</deck>
